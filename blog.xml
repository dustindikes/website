<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:content="http://purl.org/rss/1.0/modules/content">
  <channel>
    <title>Dustin Dikes - Blog</title>
    <link>https://dustindikes.com/blog</link>
    <description>Blog posts related to security, OSINT, bug bounty, CTFs, etc</description>
    <language>en-us</language>
    <atom:link href="https://dustindikes.com/blog.xml" rel="self" type="application/rss+xml" />
      <item>
        <title>HTB Skills Assessment - File Inclusion Writeup</title>
        <link>https://dustindikes.com/blog/htb-skills-assessment-lfi.html</link>
        <guid>https://dustindikes.com/blog/htb-skills-assessment-lfi.html</guid>
        <dc:creator>Dustin Dikes</dc:creator>
        <pubDate>Fri, 30 Jan 2026 00:00:00</pubDate>
        <description><![CDATA[<h2>Scenario</h2>
<p>For this assessment, you are contracted by a company to do a web application penetration test of the main company website.</p>
<p>The scenario for this assessment was short, but it included this key piece of information:</p>
<blockquote>
<p>the CISO mentioned that last year's penetration test resulted in zero findings, however they have added a job application form since then, and so it may be a point of interest</p>
</blockquote>
<p>Since the job application form is new, that was where I first focused my attention.</p>
<h2>Apply</h2>
<p>The first thing I noticed was the Resume file selector in the form. It says it only allows <strong>.docx</strong> and <strong>.pdf</strong> files are allowed, however it allowed me to upload a <strong>shell.php</strong> file, so there is no frontend or backend validation of the file type.</p>
<p><img alt="" src="https://dustindikes.com/assets/img/HTB-LFI-001.png" /></p>
<p>My next step was to try to find the upload directory for the resumes. I tried to visit <strong>/uploads/shell.php</strong>, however that didn't seem to work. I figured that it may be using a less obvious directory, so I ran <a href="https://www.kali.org/tools/dirb/">dirb</a> with the default wordlist. This gave me 4 directories:</p>
<ul>
<li>/api</li>
<li>/css</li>
<li>/images</li>
<li>/uploads</li>
</ul>
<p><img alt="" src="https://dustindikes.com/assets/img/HTB-LFI-002.png" /></p>
<p>It appears I was correct about the <strong>/uploads</strong> directory, however the file names must be changing.</p>
<p>I'll be honest, at this point I spent way too much time trying the same things over and over to locate the uploaded file. What I needed to do was branch out into other areas of the website. Since the scenario specifically mentioned the apply page, and the contact page didn't contain much, I dismissed it without trying anything.</p>
<h2>Contact</h2>
<p>Eventually I ran FFUF on the contact page  with the <strong>burp-parameter-names</strong> wordlist, which found a parameter for the page! The <strong>region</strong> parameter exists, and will hopefully be vulnerable to LFI.</p>
<p><img alt="" src="https://dustindikes.com/assets/img/HTB-LFI-003.png" /></p>
<p>I should be able to use this to load the shell, but I still need to find where the shell was uploaded to.</p>
<h2>Image API</h2>
<p>Another strange thing I noticed was the images are loaded on the site. Instead of using a path directly to them, an API image.php file is used with a parameter containing what seems to be an MD5 hash. For example, this is the logo URL:</p>
<p>http://83.136.253.144:53872/api/image.php?p=a4cbc9532b6364a008e2ac58347e3e3c</p>
<p>I tried to use the <strong>p</strong> parameter to load a different file, but found it seemed to be blocking any string that contained a <strong>../</strong>, so I decided to try using <strong>..//</strong> to see if it was only instances of ../, which would change ....// into ../</p>
<p>Fortunately, that was the case! At this point I did get hung up for quite some time because I didn't realize that the browser would not render the response properly, because it is supposed to be an image file. At some point I tried it as a curl command and found that it was spitting out file contents.</p>
<p>I realized I could load the contents of any PHP file, like so:</p>
<p><code>curl 'http://83.136.253.144:53872/api/image.php?p=....//api/application.php'</code></p>
<p>This was very helpful, as it let me view how the file upload worked:</p>
<p><img alt="" src="https://dustindikes.com/assets/img/HTB-LFI-004.png" /></p>
<p>By reading through this code, I could see that the file was being renamed to the MD5 hash of the file itself. That means that the file I uploaded should be at <strong>/uploads/{md5hash}.php </strong>.</p>
<p>I used the <strong>md5sum</strong> command to get the hash of my shell file:</p>
<p><code>$ md5sum shell.php
fc023fcacb27a7ad72d605c4e300b389  shell.php</code></p>
<h2>RCE with shell.php</h2>
<p>At this point I knew I could probably load my shell via the <strong>region</strong> parameter on the contact page. By running a curl command using the </p>
<p><img alt="" src="https://dustindikes.com/assets/img/HTB-LFI-005.png" /></p>
<p>It seems that it is removing all instances of "." and "/" which makes LFI difficult. I know that <strong>$_GET</strong> URL decodes the value automatically, then if it gets past the dot slash check, it url decodes it again with <strong>urldecode</strong>. This got me thinking that I could probably double URL encode it, and it may work, so I tried this to load my shell file:</p>
<p>http://83.136.249.34:32864/contact.php?region=%252E%252E%252Fuploads%252Ffc023fcacb27a7ad72d605c4e300b389&amp;cmd=id'</p>
<p>That string is a double URL encoded version of <strong>../uploads/fc023fcacb27a7ad72d605c4e300b389</strong>, and I also included the <strong>&amp;cmd=id</strong> parameter, which worked! This was displayed on the page:</p>
<blockquote>
<p>uid=33(www-data) gid=33(www-data) groups=33(www-data)</p>
</blockquote>
<h2>Getting the flag!</h2>
<p>I was then able to use this shell to <strong>ls</strong> the <strong>/</strong> directory:</p>
<p><code>curl 'http://83.136.249.34:32864/contact.php?region=%252E%252E%252Fuploads%252Ffc023fcacb27a7ad72d605c4e300b389&amp;cmd=ls+/'
boot
dev
etc
flag_09ebca.txt
home
lib
...</code></p>
<p>And then cat the <strong>flag_093bca.txt</strong> file:</p>
<p><code>curl 'http://83.136.249.34:32864/contact.php?region=%252E%252E%252Fuploads%252Ffc023fcacb27a7ad72d605c4e300b389&amp;cmd=cat+/flag_09ebca.txt'
...
eedbb78d4800aa45573840ed6bd2d1e3
...</code></p>
<h2>Lessons Learned</h2>
<ol>
<li>Don't make assumptions about if something, deciding that it's not vulnerable. Assume everything is vulnerable, then try to hack it.</li>
<li>If a server is setting the mime type of a request to an image but it is returning text, it will not render the text in the browser. Use curl or some other tool to make the request.</li>
</ol>]]></description>
        <content:encoded>&lt;h2&gt;Scenario&lt;/h2&gt;
&lt;p&gt;For this assessment, you are contracted by a company to do a web application penetration test of the main company website.&lt;/p&gt;
&lt;p&gt;The scenario for this assessment was short, but it included this key piece of information:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the CISO mentioned that last year&#x27;s penetration test resulted in zero findings, however they have added a job application form since then, and so it may be a point of interest&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since the job application form is new, that was where I first focused my attention.&lt;/p&gt;
&lt;h2&gt;Apply&lt;/h2&gt;
&lt;p&gt;The first thing I noticed was the Resume file selector in the form. It says it only allows &lt;strong&gt;.docx&lt;/strong&gt; and &lt;strong&gt;.pdf&lt;/strong&gt; files are allowed, however it allowed me to upload a &lt;strong&gt;shell.php&lt;/strong&gt; file, so there is no frontend or backend validation of the file type.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/HTB-LFI-001.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;My next step was to try to find the upload directory for the resumes. I tried to visit &lt;strong&gt;/uploads/shell.php&lt;/strong&gt;, however that didn&#x27;t seem to work. I figured that it may be using a less obvious directory, so I ran &lt;a href=&quot;https://www.kali.org/tools/dirb/&quot;&gt;dirb&lt;/a&gt; with the default wordlist. This gave me 4 directories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/api&lt;/li&gt;
&lt;li&gt;/css&lt;/li&gt;
&lt;li&gt;/images&lt;/li&gt;
&lt;li&gt;/uploads&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/HTB-LFI-002.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It appears I was correct about the &lt;strong&gt;/uploads&lt;/strong&gt; directory, however the file names must be changing.&lt;/p&gt;
&lt;p&gt;I&#x27;ll be honest, at this point I spent way too much time trying the same things over and over to locate the uploaded file. What I needed to do was branch out into other areas of the website. Since the scenario specifically mentioned the apply page, and the contact page didn&#x27;t contain much, I dismissed it without trying anything.&lt;/p&gt;
&lt;h2&gt;Contact&lt;/h2&gt;
&lt;p&gt;Eventually I ran FFUF on the contact page  with the &lt;strong&gt;burp-parameter-names&lt;/strong&gt; wordlist, which found a parameter for the page! The &lt;strong&gt;region&lt;/strong&gt; parameter exists, and will hopefully be vulnerable to LFI.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/HTB-LFI-003.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;I should be able to use this to load the shell, but I still need to find where the shell was uploaded to.&lt;/p&gt;
&lt;h2&gt;Image API&lt;/h2&gt;
&lt;p&gt;Another strange thing I noticed was the images are loaded on the site. Instead of using a path directly to them, an API image.php file is used with a parameter containing what seems to be an MD5 hash. For example, this is the logo URL:&lt;/p&gt;
&lt;p&gt;http://83.136.253.144:53872/api/image.php?p=a4cbc9532b6364a008e2ac58347e3e3c&lt;/p&gt;
&lt;p&gt;I tried to use the &lt;strong&gt;p&lt;/strong&gt; parameter to load a different file, but found it seemed to be blocking any string that contained a &lt;strong&gt;../&lt;/strong&gt;, so I decided to try using &lt;strong&gt;..//&lt;/strong&gt; to see if it was only instances of ../, which would change ....// into ../&lt;/p&gt;
&lt;p&gt;Fortunately, that was the case! At this point I did get hung up for quite some time because I didn&#x27;t realize that the browser would not render the response properly, because it is supposed to be an image file. At some point I tried it as a curl command and found that it was spitting out file contents.&lt;/p&gt;
&lt;p&gt;I realized I could load the contents of any PHP file, like so:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;curl &#x27;http://83.136.253.144:53872/api/image.php?p=....//api/application.php&#x27;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This was very helpful, as it let me view how the file upload worked:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/HTB-LFI-004.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;By reading through this code, I could see that the file was being renamed to the MD5 hash of the file itself. That means that the file I uploaded should be at &lt;strong&gt;/uploads/{md5hash}.php &lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I used the &lt;strong&gt;md5sum&lt;/strong&gt; command to get the hash of my shell file:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ md5sum shell.php
fc023fcacb27a7ad72d605c4e300b389  shell.php&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;RCE with shell.php&lt;/h2&gt;
&lt;p&gt;At this point I knew I could probably load my shell via the &lt;strong&gt;region&lt;/strong&gt; parameter on the contact page. By running a curl command using the &lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/HTB-LFI-005.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It seems that it is removing all instances of &quot;.&quot; and &quot;/&quot; which makes LFI difficult. I know that &lt;strong&gt;$_GET&lt;/strong&gt; URL decodes the value automatically, then if it gets past the dot slash check, it url decodes it again with &lt;strong&gt;urldecode&lt;/strong&gt;. This got me thinking that I could probably double URL encode it, and it may work, so I tried this to load my shell file:&lt;/p&gt;
&lt;p&gt;http://83.136.249.34:32864/contact.php?region=%252E%252E%252Fuploads%252Ffc023fcacb27a7ad72d605c4e300b389&amp;amp;cmd=id&#x27;&lt;/p&gt;
&lt;p&gt;That string is a double URL encoded version of &lt;strong&gt;../uploads/fc023fcacb27a7ad72d605c4e300b389&lt;/strong&gt;, and I also included the &lt;strong&gt;&amp;amp;cmd=id&lt;/strong&gt; parameter, which worked! This was displayed on the page:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;uid=33(www-data) gid=33(www-data) groups=33(www-data)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Getting the flag!&lt;/h2&gt;
&lt;p&gt;I was then able to use this shell to &lt;strong&gt;ls&lt;/strong&gt; the &lt;strong&gt;/&lt;/strong&gt; directory:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;curl &#x27;http://83.136.249.34:32864/contact.php?region=%252E%252E%252Fuploads%252Ffc023fcacb27a7ad72d605c4e300b389&amp;amp;cmd=ls+/&#x27;
boot
dev
etc
flag_09ebca.txt
home
lib
...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;And then cat the &lt;strong&gt;flag_093bca.txt&lt;/strong&gt; file:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;curl &#x27;http://83.136.249.34:32864/contact.php?region=%252E%252E%252Fuploads%252Ffc023fcacb27a7ad72d605c4e300b389&amp;amp;cmd=cat+/flag_09ebca.txt&#x27;
...
eedbb78d4800aa45573840ed6bd2d1e3
...&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Lessons Learned&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Don&#x27;t make assumptions about if something, deciding that it&#x27;s not vulnerable. Assume everything is vulnerable, then try to hack it.&lt;/li&gt;
&lt;li&gt;If a server is setting the mime type of a request to an image but it is returning text, it will not render the text in the browser. Use curl or some other tool to make the request.&lt;/li&gt;
&lt;/ol&gt;</content:encoded>
      </item>
      <item>
        <title>Snyk Fetch the Flag 2026 CTF Writeup</title>
        <link>https://dustindikes.com/blog/snyk-fetch-the-flag-2026-ctf-writeup.html</link>
        <guid>https://dustindikes.com/blog/snyk-fetch-the-flag-2026-ctf-writeup.html</guid>
        <dc:creator>Dustin Dikes</dc:creator>
        <pubDate>Mon, 16 Feb 2026 00:00:00</pubDate>
        <description><![CDATA[<p>This is a writeup for the <a href="https://ctf.snyk.io/ctf/fetch-the-flag-2026">Snyk Fetch The Flag 2026 CTF</a>. I competed in this CTF with a team of two other Defcon 509 members. This is my first CTF in a team, and it was really fun! I enjoy talking through things with my team and solving things together. I found this to be much better than spinning my wheels as an individual (though that can be fun still).</p>
<h2>Forensics - Void Step</h2>
<p>The forensics category had a single challenge, Void Step, with 10 flags. Unlike other categories where you have to break something to gain a flag, this one provided you a <strong>pcap</strong> file. Each flag was an answer to a question.</p>
<p>This was a really large pcap file (721148 entries), so it required a lot of filtering and searching around to find the answers.</p>
<p>Something interesting to note, was that the flag format gave you a hint to the answer. For instance, the open ports flag format was "x" implying that it was a single digit number. After getting a few flags, we realized that the format always matched, so this helped narrow down some answers.</p>
<p>I still haven't gotten in a good habit of documenting CTFs while I go (though I'm going to put in a real effort to do that on the next one), so this writeup is from my memory. The flags are just in the order from the CTF, not the order we found them in.</p>
<h3>Flag 1</h3>
<blockquote>
<p>How many decoy hosts are randomized in this reconnaissance evasion technique?</p>
</blockquote>
<p>This one took us a while to sort out and it was one of our last flags. We used "Statistics &gt; IPv4 Statistics &gt; All Addresses" to get a list of IP addresses. We then went through that and pulled out the public IPs, of which there were 10. 10 was not the answer, so we were stuck for a while.</p>
<p><img alt="" src="https://dustindikes.com/assets/img/SNYK-CTF-03.png" /></p>
<p>While looking into detecting network attacks in wireshark, I added the filter "tcp.dstport == 7" for detecting TCP ping sweeps that I found <a href="https://www.infosecmatter.com/detecting-network-attacks-with-wireshark/">here</a>. This gave me a list of 12 IP addresses, however 192.168.1.23 was listed twice. I decided that maybe we needed to add the 192.168.1.27 to the count, which gave us 11. This was the correct flag.</p>
<p><img alt="" src="https://dustindikes.com/assets/img/SNYK-CTF-04.png" /></p>
<h3>Flag 2</h3>
<blockquote>
<p>What is the real attacker IP address?</p>
</blockquote>
<p>This one seemed to be a local IP since the format was "xxx.xxx.x.xx", but as a team we went back and forth on whether this was local or if they wanted the external IP. In the end we couldn't find any way to determine an external IP that matched this format, so we decided to try the local IP. Majority of the requests were from local IP 192.168.1.27, so we tried that and it was correct.</p>
<h3>Flag 3</h3>
<blockquote>
<p>How many open ports did the attacker find?</p>
</blockquote>
<p>I will be honest here, the flag format was simply "x" so I knew this had to be a one digit number. I tried 1-4 and the flag was 4. Probably I should have tried to find a way to determine the actual ports, but this is how I got it.</p>
<h3>Flag 4</h3>
<blockquote>
<p>What web enumeration tool did the attacker use?</p>
</blockquote>
<p>After filtering the list down using "http", we noticed there were a bunch of requests with clear enumeration trying to find files (.bash_history, .bashrc.bak, etc). When clicking on one of those and viewing the HTTP info, the <strong>User-Agent</strong> is set to <strong>gobuster/3.8</strong>, which is an enumeration tool and the answer for this flag.</p>
<p><img alt="" src="https://dustindikes.com/assets/img/SNYK-CTF-01.png" /></p>
<h3>Flag 5</h3>
<blockquote>
<p>What is the first endpoint discovered by the attacker?</p>
</blockquote>
<p>We found this one by filtering on status code 200 using "http.response.code == 200". Scrolling through the short results list, the first endpoint that wasn't just "/" was "/about" which was the flag.</p>
<p><img alt="" src="https://dustindikes.com/assets/img/SNYK-CTF-02.png" /></p>
<h3>Flag 6</h3>
<blockquote>
<p>What was the first extension tested during the enumeration</p>
</blockquote>
<p>Filtering by "http" showed all the gobuster requests. The first one with an extension was ".bash_history.html", so the answer was "html".</p>
<h3>Flag 7</h3>
<blockquote>
<p>What is the full vulnerable request parameter used in the attack?</p>
</blockquote>
<p>Scrolling down in the "http" filtered list, we found requests to <strong>/read</strong> using the "?file=" parameter. It appears the attacker realized there was a local file inclusion vulnerability with this paramter, and they were trying to make some requests to get files. The name of this parameter "file" was the answer.</p>
<p><img alt="" src="https://dustindikes.com/assets/img/SNYK-CTF-05.png" /></p>
<h3>Flag 8</h3>
<blockquote>
<p>What is the username discovered by the attacker?</p>
</blockquote>
<p>With the discovered <strong>/read</strong> requests, right clicking on the <strong>/etc/passwd</strong> attempt showed the response, which successfully returned the contents of that file, including the username <strong>zoro</strong>.</p>
<p><img alt="" src="https://dustindikes.com/assets/img/SNYK-CTF-06.png" /></p>
<h3>Flag 9</h3>
<blockquote>
<p>What authentication-related file did the attacker attempt to access?</p>
</blockquote>
<p>The other file the attacker attempted to request (unsuccessfully) using <strong>/read</strong> was <strong>/home/zoro/.ssh/authorized_keys</strong>. This was the answer for this flag.</p>
<h3>Flag 10</h3>
<blockquote>
<p>What time (HH:MM:SS,MS) did the attacker start brute forcing for SSH?</p>
</blockquote>
<p>This one seemed to be tripping people up, as it had less solves and the points hadn't degraded down to 100 yet. We managed to get this one before the rewrote the question to make it easier. Previously it just said "brute forcing the password" or something like that, as opposed to "brute forcing SSH".</p>
<p>To find this, we filtered the list based on SSH, assuming the attacker would be trying to brute force a password via SSH using the <strong>zoro</strong> user they found. Looking at the first of many SSHv2 requests, we first tried the <strong>Arrival Time</strong>, which was wrong. We then tried the <strong>UTC Arrival Time</strong> and that one was correct. The correct timestamp was <strong>2025-10-24T09:02:47.214758477Z</strong>, so the flag was <strong>09:02:47,21</strong>.</p>
<p><img alt="" src="https://dustindikes.com/assets/img/SNYK-CTF-07.png" /></p>
<h2>Other challenges</h2>
<p>We made attempts to get flags on the <strong>AI</strong> and <strong>Web</strong> sections, but didn't manage to get any flags. We could usually figure out what we were supposed to do to get a flag, but struggled to make that happen. It was still giving it a go, however and the forensics section was really fun!</p>]]></description>
        <content:encoded>&lt;p&gt;This is a writeup for the &lt;a href=&quot;https://ctf.snyk.io/ctf/fetch-the-flag-2026&quot;&gt;Snyk Fetch The Flag 2026 CTF&lt;/a&gt;. I competed in this CTF with a team of two other Defcon 509 members. This is my first CTF in a team, and it was really fun! I enjoy talking through things with my team and solving things together. I found this to be much better than spinning my wheels as an individual (though that can be fun still).&lt;/p&gt;
&lt;h2&gt;Forensics - Void Step&lt;/h2&gt;
&lt;p&gt;The forensics category had a single challenge, Void Step, with 10 flags. Unlike other categories where you have to break something to gain a flag, this one provided you a &lt;strong&gt;pcap&lt;/strong&gt; file. Each flag was an answer to a question.&lt;/p&gt;
&lt;p&gt;This was a really large pcap file (721148 entries), so it required a lot of filtering and searching around to find the answers.&lt;/p&gt;
&lt;p&gt;Something interesting to note, was that the flag format gave you a hint to the answer. For instance, the open ports flag format was &quot;x&quot; implying that it was a single digit number. After getting a few flags, we realized that the format always matched, so this helped narrow down some answers.&lt;/p&gt;
&lt;p&gt;I still haven&#x27;t gotten in a good habit of documenting CTFs while I go (though I&#x27;m going to put in a real effort to do that on the next one), so this writeup is from my memory. The flags are just in the order from the CTF, not the order we found them in.&lt;/p&gt;
&lt;h3&gt;Flag 1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;How many decoy hosts are randomized in this reconnaissance evasion technique?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This one took us a while to sort out and it was one of our last flags. We used &quot;Statistics &amp;gt; IPv4 Statistics &amp;gt; All Addresses&quot; to get a list of IP addresses. We then went through that and pulled out the public IPs, of which there were 10. 10 was not the answer, so we were stuck for a while.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/SNYK-CTF-03.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;While looking into detecting network attacks in wireshark, I added the filter &quot;tcp.dstport == 7&quot; for detecting TCP ping sweeps that I found &lt;a href=&quot;https://www.infosecmatter.com/detecting-network-attacks-with-wireshark/&quot;&gt;here&lt;/a&gt;. This gave me a list of 12 IP addresses, however 192.168.1.23 was listed twice. I decided that maybe we needed to add the 192.168.1.27 to the count, which gave us 11. This was the correct flag.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/SNYK-CTF-04.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Flag 2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What is the real attacker IP address?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This one seemed to be a local IP since the format was &quot;xxx.xxx.x.xx&quot;, but as a team we went back and forth on whether this was local or if they wanted the external IP. In the end we couldn&#x27;t find any way to determine an external IP that matched this format, so we decided to try the local IP. Majority of the requests were from local IP 192.168.1.27, so we tried that and it was correct.&lt;/p&gt;
&lt;h3&gt;Flag 3&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;How many open ports did the attacker find?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I will be honest here, the flag format was simply &quot;x&quot; so I knew this had to be a one digit number. I tried 1-4 and the flag was 4. Probably I should have tried to find a way to determine the actual ports, but this is how I got it.&lt;/p&gt;
&lt;h3&gt;Flag 4&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What web enumeration tool did the attacker use?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;After filtering the list down using &quot;http&quot;, we noticed there were a bunch of requests with clear enumeration trying to find files (.bash_history, .bashrc.bak, etc). When clicking on one of those and viewing the HTTP info, the &lt;strong&gt;User-Agent&lt;/strong&gt; is set to &lt;strong&gt;gobuster/3.8&lt;/strong&gt;, which is an enumeration tool and the answer for this flag.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/SNYK-CTF-01.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Flag 5&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What is the first endpoint discovered by the attacker?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We found this one by filtering on status code 200 using &quot;http.response.code == 200&quot;. Scrolling through the short results list, the first endpoint that wasn&#x27;t just &quot;/&quot; was &quot;/about&quot; which was the flag.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/SNYK-CTF-02.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Flag 6&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What was the first extension tested during the enumeration&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Filtering by &quot;http&quot; showed all the gobuster requests. The first one with an extension was &quot;.bash_history.html&quot;, so the answer was &quot;html&quot;.&lt;/p&gt;
&lt;h3&gt;Flag 7&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What is the full vulnerable request parameter used in the attack?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Scrolling down in the &quot;http&quot; filtered list, we found requests to &lt;strong&gt;/read&lt;/strong&gt; using the &quot;?file=&quot; parameter. It appears the attacker realized there was a local file inclusion vulnerability with this paramter, and they were trying to make some requests to get files. The name of this parameter &quot;file&quot; was the answer.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/SNYK-CTF-05.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Flag 8&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What is the username discovered by the attacker?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With the discovered &lt;strong&gt;/read&lt;/strong&gt; requests, right clicking on the &lt;strong&gt;/etc/passwd&lt;/strong&gt; attempt showed the response, which successfully returned the contents of that file, including the username &lt;strong&gt;zoro&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/SNYK-CTF-06.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Flag 9&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What authentication-related file did the attacker attempt to access?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The other file the attacker attempted to request (unsuccessfully) using &lt;strong&gt;/read&lt;/strong&gt; was &lt;strong&gt;/home/zoro/.ssh/authorized_keys&lt;/strong&gt;. This was the answer for this flag.&lt;/p&gt;
&lt;h3&gt;Flag 10&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;What time (HH:MM:SS,MS) did the attacker start brute forcing for SSH?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This one seemed to be tripping people up, as it had less solves and the points hadn&#x27;t degraded down to 100 yet. We managed to get this one before the rewrote the question to make it easier. Previously it just said &quot;brute forcing the password&quot; or something like that, as opposed to &quot;brute forcing SSH&quot;.&lt;/p&gt;
&lt;p&gt;To find this, we filtered the list based on SSH, assuming the attacker would be trying to brute force a password via SSH using the &lt;strong&gt;zoro&lt;/strong&gt; user they found. Looking at the first of many SSHv2 requests, we first tried the &lt;strong&gt;Arrival Time&lt;/strong&gt;, which was wrong. We then tried the &lt;strong&gt;UTC Arrival Time&lt;/strong&gt; and that one was correct. The correct timestamp was &lt;strong&gt;2025-10-24T09:02:47.214758477Z&lt;/strong&gt;, so the flag was &lt;strong&gt;09:02:47,21&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://dustindikes.com/assets/img/SNYK-CTF-07.png&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Other challenges&lt;/h2&gt;
&lt;p&gt;We made attempts to get flags on the &lt;strong&gt;AI&lt;/strong&gt; and &lt;strong&gt;Web&lt;/strong&gt; sections, but didn&#x27;t manage to get any flags. We could usually figure out what we were supposed to do to get a flag, but struggled to make that happen. It was still giving it a go, however and the forensics section was really fun!&lt;/p&gt;</content:encoded>
      </item>
  </channel>
</rss>